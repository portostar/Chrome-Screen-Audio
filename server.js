// Generated by CoffeeScript 1.10.0, modified internally
ffmpeg_merge = require("./ffmpeg_merge");
(function() {
  var ALLOWED_METHODS, ALLOWED_METHODS_STR, PATTERNS, commonHeaders, config, createFile, events, fs, getFile, headFile, http, httpStatus, initApp, optionsFile, patchFile, path, route, setup, setupLogger, startup, testUploadPage, tusHandler, upload, url, util, uuid, winston,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require("http");

  url = require("url");

  fs = require("fs");

  path = require("path");

  util = require("util");

  events = require("events");

  uuid = require("node-uuid");

  winston = require("winston");

  upload = require("./upload");

  setup = new events.EventEmitter();

  config = {};

  testUploadPage = function(res) {
    return fs.readFile(path.join(__dirname, "/index.html"), "utf8", function(err, data) {
      res.setHeader("Content-Type", "text/html");
      if (!err) {
        return httpStatus(res, 200, "Ok", data);
      }
      winston.error(util.inspect(err));
      return httpStatus(res, 405, "Not Allowed");
    });
  };

  optionsFile = function(req, res, query, matches) {
    return httpStatus(res, 200, "Ok");
  };

  getFile = function(req, res, query, matches) {
    var fileId, status, u;

    fileId = matches[2];
    if (fileId == null) {
      return httpStatus(res, 404, "Not Found");
    }
    u = upload.Upload(config, fileId);
    status = u.load();
    if (status.error != null) {
      return httpStatus(res, status.error[0], status.error[1]);
    }
    res.setHeader("Content-Length", status.info.finalLength);
    return u.stream().pipe(res);
  };

  createFile = function(req, res, query, matches) {
    var fileId, finalLength, status;
    fileId = matches[2];
    if (fileId != null) {
      return httpStatus(res, 400, "Invalid Request");
    }
    if (req.headers["final-length"] == null) {
      return httpStatus(res, 400, "Final-Length Required");
    }
    finalLength = parseInt(req.headers["final-length"]);
    if (isNaN(finalLength || finalLength < 0)) {
      return httpStatus(res, 400, "Final-Length Must be Non-Negative");
    }
    fileId = uuid.v1();
    status = upload.Upload(config, fileId).create(finalLength);
    if (status.error != null) {
      return httpStatus(res, status.error[0], status.error[1]);
    }
	var port = process.env.OPENSHIFT_NODEJS_PORT || config.port;
	var host = process.env.OPENSHIFT_NODEJS_IP || config.host;
    res.setHeader("Location", "http://" + host + ":" + port + "/files/" + fileId);
    return httpStatus(res, 201, "Created");
  };

  headFile = function(req, res, query, matches) {
    var fileId, info, status;
    fileId = matches[2];
    if (fileId == null) {
      return httpStatus(res, 404, "Not Found");
    }
    status = upload.Upload(config, fileId).load();
    if (status.error != null) {
      return httpStatus(res, status.error[0], status.error[1]);
    }
    info = status.info;
    res.setHeader("Offset", info.offset);
    res.setHeader("Connection", "close");
    return httpStatus(res, 200, "Ok");
  };

  patchFile = function(req, res, query, matches) {
    var contentLength, fileId, filePath, info, offsetIn, status, u, ws;
    fileId = matches[2];
    if (fileId == null) {
      return httpStatus(res, 404, "Not Found");
    }
    filePath = path.join(config.files, fileId);
    if (!fs.existsSync(filePath)) {
      return httpStatus(res, 404, "Not Found");
    }
    if (req.headers["content-type"] == null) {
      return httpStatus(res, 400, "Content-Type Required");
    }
    if (req.headers["content-type"] !== "application/offset+octet-stream") {
      return httpStatus(res, 400, "Content-Type Invalid");
    }
    if (req.headers["offset"] == null) {
      return httpStatus(res, 400, "Offset Required");
    }
    offsetIn = parseInt(req.headers["offset"]);
    if (isNaN(offsetIn || offsetIn < 0)) {
      return httpStatus(res, 400, "Offset Invalid");
    }
    if (req.headers["content-length"] == null) {
      return httpStatus(res, 400, "Content-Length Required");
    }
    contentLength = parseInt(req.headers["content-length"]);
    if (isNaN(contentLength || contentLength < 1)) {
      return httpStatus(res, 400, "Invalid Content-Length");
    }
    u = upload.Upload(config, fileId);
    status = u.load();
    if (status.error != null) {
      return httpStatus(res, status.error[0], status.error[1]);
    }
    info = status.info;
    if (offsetIn > info.offset) {
      return httpStatus(res, 400, "Invalid Offset");
    }
    ws = fs.createWriteStream(filePath, {
      flags: "r+",
      start: offsetIn
    });
    if (ws == null) {
      winston.error("unable to create file " + filePath);
      return httpStatus(res, 500, "File Error");
    }
    info.offset = offsetIn;
    info.state = "patched";
    info.patchedOn = Date.now();
    info.bytesReceived = 0;
    req.pipe(ws);
    req.on("data", function(buffer) {
      winston.debug("old Offset " + info.offset);
      info.bytesReceived += buffer.length;
      info.offset += buffer.length;
      winston.debug("new Offset " + info.offset);
      if (info.offset > info.finalLength) {
        return httpStatus(res, 500, "Exceeded Final-Length");
      }
      if (info.received > contentLength) {
        return httpStatus(res, 500, "Exceeded Content-Length");
      }
    });
    req.on("end", function() {
      if (!res.headersSent) {
        httpStatus(res, 200, "Ok");
      }
      return u.save(info);
    });
    req.on("close", function() {
      winston.error("client abort. close the file stream " + fileId);
      return ws.end();
    });
    ws.on("close", function() {
      winston.info("closed the file stream " + fileId);
      return winston.debug(util.inspect(res));
    });
    return ws.on("error", function(e) {
      winston.error("closed the file stream " + fileId + " " + (util.inspect(e)));
      return httpStatus(res, 500, "File Error");
    });
  };

  httpStatus = function(res, statusCode, reason, body) {
    if (body == null) {
      body = '';
    }
    res.writeHead(statusCode, reason);
    return res.end(body);
  };

  ALLOWED_METHODS = ["HEAD", "PATCH", "POST", "OPTIONS", "GET"];

  ALLOWED_METHODS_STR = ALLOWED_METHODS.join(",");

  PATTERNS = [
    {
      match: /files(\/(.+))*/,
      HEAD: headFile,
      PATCH: patchFile,
      POST: createFile,
      OPTIONS: optionsFile,
      GET: getFile
    }
  ];

  route = function(req, res) {
    var i, len, matches, parsed, pattern, query, ref, urlPath;
    winston.debug(util.inspect(req));
    if (ref = req.method, indexOf.call(ALLOWED_METHODS, ref) < 0) {
      return httpStatus(res, 405, "Not Allowed");
    }
    parsed = url.parse(req.url, true);
    urlPath = parsed.pathname;
    console.log("URLPATH: " + urlPath);
	query = parsed.query;
    if (urlPath === "/") {
	console.log("test");
      if (req.method !== "GET") {
		  console.log("!GET");
        return httpStatus(res, 405, "Not Allowed");
      }
	  console.log("query.action:"+query.action);
			if (query.action=="doesexist")
			{
				try {
					// Query the entry
					stats = fs.lstatSync("files/"+query.filename);
					console.log("EXISTS");
					return httpStatus(res, 200, "Ok", "EXISTS");
				}
				catch (e) {
					console.log("DOES NOT EXIST");
					return httpStatus(res, 200, "Ok", "NOT_EXISTS");
				}
				
			} else
			if (query.action=="process")
			{
				if (query.audio=="")
				{
					console.log("No audio URL");
				} else
				if (query.video=="")
				{
					console.log("No video URL");
				} else {
						console.log("FFMPEG");
						
						console.log("starting merge");
						ffmpeg_merge.merge(query.audio, query.video);
						console.log("DONE");
				}
			}
      return testUploadPage(res);
    }
    if (!(urlPath.length > 1)) {
      return httpStatus(res, 405, "Not Allowed");
    }
    
    for (i = 0, len = PATTERNS.length; i < len; i++) {
      pattern = PATTERNS[i];
      matches = urlPath.match(pattern.match);
      winston.debug("" + (util.inspect(matches)));
      if (matches != null) {
        return pattern[req.method](req, res, query, matches);
      }
    }
    return httpStatus(res, 405, "Not Allowed");
  };

  commonHeaders = function(res) {
    res.setHeader("Server", config.server);
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", ALLOWED_METHODS_STR);
    res.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Final-Length, Offset");
    return res.setHeader("Access-Control-Expose-Headers", "Location");
  };

  tusHandler = function(req, res) {
    commonHeaders(res);
    return route(req, res);
  };

  setupLogger = function(logDir, logFileName, logRotateSize) {
    var error, error1, logfw, opts;
    try {
      fs.mkdirSync(logDir);
    } catch (error1) {
      error = error1;
      if ((error != null) && error.code !== "EEXIST") {
        winston.error(util.inspect(error));
        process.exit(1);
      }
    }
    opts = {
      flags: 'a',
      encoding: 'utf8',
      bufferSize: 0
    };
    logfw = fs.createWriteStream(logFileName, opts);
    logfw.once("open", function(logfd) {
      return fs.watchFile(logFileName, function(cur, prev) {
        if (cur.size > logRotateSize) {
          fs.truncate(logfd, 0);
          return winston.warn("Rotated logfile");
        }
      });
    });
    process.on('uncaughtException', function(err) {
      winston.error("uncaught exception " + (util.inspect(err)));
      return logfw.once("drain", function() {
        return process.exit(1);
      });
    });
    winston.add(winston.transports.File, {
      stream: logfw,
      level: config.logLevel,
      json: false,
      timestamp: true
    });
    return winston.remove(winston.transports.Console);
  };

  initApp = function(args) {
    var configFileName, error, error1, error2, fileNamePrefix, logDir, logFileName;
    fileNamePrefix = path.basename(__filename, path.extname(__filename));
    configFileName = path.join(__dirname, fileNamePrefix + ".json");
    winston.debug("Reading " + configFileName);
    try {
      config = require(configFileName);
    } catch (error1) {
      error = error1;
      winston.error("Failed to load " + configFileName);
    }
    winston.debug(util.inspect(config));
    logDir = config.logDir || path.join(__dirname, "logs");
    logFileName = path.join(logDir, fileNamePrefix + ".log");
    setupLogger(logDir, logFileName, config.logRotateSize);
    try {
      fs.mkdirSync(config.files);
    } catch (error2) {
      error = error2;
      if ((error != null) && error.code !== "EEXIST") {
        winston.error(util.inspect(error));
        process.exit(1);
      }
    }
    return setup.emit("setupComplete");
  };

  startup = function(args) {
    setup.once("setupComplete", function() {
      var server;
      server = http.createServer(tusHandler);
      server.timeout = 30000;
      server.listen(config.port);
	  var port = process.env.OPENSHIFT_NODEJS_PORT || config.port;
	  var host = process.env.OPENSHIFT_NODEJS_IP || config.host;
      return winston.info("Server running at http://" + host + ":" + port + "/");
    });
    return initApp(args);
  };

  startup(process.argv);

}).call(this);
